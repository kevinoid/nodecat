<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>nodecat</h1>
      <dl>
        <dt>concatenates files around stdin</dt>
        <dd><pre><code>const testContent = Buffer.allocUnsafe(256);
for (let i = 0; i &#x3C; 256; i += 1) {
  testContent[i] = i;
}
const proc = execFile(
  process.execPath,
  [
    binPath,
    testFiles[0],
    &#x27;-&#x27;,
    testFiles[1]
  ],
  {encoding: null},
  (err, stdout, stderr) =&#x3E; {
    assert.ifError(err);
    const expected = Buffer.concat([
      testFileContent[testFiles[0]],
      testContent,
      testFileContent[testFiles[1]]
    ]);
    if (typeof stdout === &#x27;string&#x27;) {
      // Node 0.10 doesn&#x27;t support returning Buffer
      deepEqual(stdout, String(expected));
      deepEqual(stderr, &#x27;&#x27;);
    } else {
      deepEqual(stdout, expected);
      deepEqual(stderr, Buffer.alloc(0));
    }
    done();
  }
);
proc.stdin.end(testContent);</code></pre></dd>
        <dt>exits code 1 with error message for non-existent file</dt>
        <dd><pre><code>const testContent = Buffer.allocUnsafe(256);
for (let i = 0; i &#x3C; 256; i += 1) {
  testContent[i] = i;
}
const badFilename = &#x27;nonexistent.txt&#x27;;
const proc = execFile(
  process.execPath,
  [
    binPath,
    badFilename,
    testFiles[0],
    &#x27;-&#x27;,
    testFiles[1]
  ],
  {encoding: null},
  (err, stdout, stderr) =&#x3E; {
    assert.strictEqual(err.code, 1);
    // stdout has data that can be read
    const expected = Buffer.concat([
      testFileContent[testFiles[0]],
      testContent,
      testFileContent[testFiles[1]]
    ]);
    if (typeof stdout === &#x27;string&#x27;) {
      // Node 0.10 doesn&#x27;t support returning Buffer
      deepEqual(stdout, String(expected));
    } else {
      deepEqual(stdout, expected);
    }
    // stderr contains an error message with the problematic file
    const stderrStr = String(stderr);
    assert(
      stderrStr.indexOf(badFilename) &#x3E;= 0,
      &#x60;&#x22;${stderrStr}&#x22; should contain &#x22;${badFilename}&#x22;&#x60;
    );
    done();
  }
);
proc.stdin.end(testContent);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>AggregateError</h1>
      <dl>
        <dt>sets .message from argument</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new AggregateError(testMsg);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>can be instantiated without arguments</dt>
        <dd><pre><code>const a = new AggregateError();
assert(a.message, &#x27;has default message&#x27;);</code></pre></dd>
        <dt>behaves like an Array</dt>
        <dd><pre><code>const a = new AggregateError();
assert.strictEqual(a.length, 0);
const testError = new Error(&#x27;test&#x27;);
a.push(testError);
assert.strictEqual(a.length, 1);
assert.strictEqual(a[0], testError);</code></pre></dd>
        <dt>can be instantiated without new</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = AggregateError(testMsg);
assert(a instanceof AggregateError);
assert.strictEqual(a.message, testMsg);</code></pre></dd>
        <dt>inherits from Error</dt>
        <dd><pre><code>const testMsg = &#x27;test message&#x27;;
const a = new AggregateError(testMsg);
assert(a instanceof Error);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>nodecat command</h1>
      <dl>
        <dt>interprets  as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets - as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets file.txt as file.txt with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -- file.txt as file.txt with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets file.txt -- as file.txt with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets file.txt -- file.txt as file.txt file.txt with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -- as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -- - as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -- -- as -- with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -u as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -u - as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets - -u - as - - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -- -u - as -u - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -u -- - as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -u -- -u - as -u - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -uu as - with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -uu -- -uu as -uu with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>interprets -- -a as -a with match(fileStreams: match(-: typeOf(&#x22;object&#x22;)))</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match(expectFiles),
    expectOpts,
    match.func
  );
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, sinon.mock().never());
nodecat.verify();</code></pre></dd>
        <dt>prints error and exits for -a</dt>
        <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  outStream,
  errStream
};
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), expectErrMsg);
  done();
});</code></pre></dd>
        <dt>prints error and exits for --unknown</dt>
        <dd><pre><code>const outStream = new stream.PassThrough();
const errStream = new stream.PassThrough();
const options = {
  outStream,
  errStream
};
const allArgs = RUNTIME_ARGS.concat(args);
nodecatCmd(allArgs, options, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  assert.strictEqual(outStream.read(), null);
  assert.match(String(errStream.read()), expectErrMsg);
  done();
});</code></pre></dd>
        <dt>yields 0 for non-Error nodecat result</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match([&#x27;-&#x27;]),
    match.object,
    match.func
  )
  .yields(null);
nodecatCmd([], {}, (err, code) =&#x3E; {
  assert.ifError(err);
  assert.strictEqual(code, 0);
  done();
});</code></pre></dd>
        <dt>yields non-0 for Error nodecat result</dt>
        <dd><pre><code>const errTest = new Error(&#x27;test error&#x27;);
nodecat = sinon.mock()
  .once()
  .withArgs(
    match([&#x27;-&#x27;]),
    match.object,
    match.func
  )
  .yields(errTest);
nodecatCmd([], {}, (err, code) =&#x3E; {
  // Note:  Error is not propagated, since it is fully handled by nodecat
  assert.ifError(err);
  assert.isAtLeast(code, 1);
  done();
});</code></pre></dd>
        <dt>throws TypeError for non-function callback</dt>
        <dd><pre><code>assert.throws(
  () =&#x3E; { nodecatCmd(RUNTIME_ARGS, {}, true); },
  TypeError,
  /\bcallback\b/
);</code></pre></dd>
        <dt>yields TypeError for non-object options</dt>
        <dd><pre><code>nodecatCmd([], true, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-Readable in</dt>
        <dd><pre><code>nodecatCmd([], {inStream: {}}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.inStream\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-Writable outStream</dt>
        <dd><pre><code>nodecatCmd([], {outStream: new stream.Readable()}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.outStream\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-Writable errStream</dt>
        <dd><pre><code>nodecatCmd([], {errStream: new stream.Readable()}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.errStream\b/);
  done();
});</code></pre></dd>
        <dt>returns undefined when called with a function</dt>
        <dd><pre><code>nodecat = sinon.mock()
  .once()
  .withArgs(
    match([&#x27;-&#x27;]),
    match.object,
    match.func
  );
const result = nodecatCmd(RUNTIME_ARGS, sinon.mock().never());
nodecat.verify();
assert.strictEqual(result, undefined);</code></pre></dd>
        <dt>returns a Promise when called without a function</dt>
        <dd><pre><code>nodecat = sinon.stub();
const result = nodecatCmd(RUNTIME_ARGS);
assert(result instanceof global.Promise);</code></pre></dd>
        <dt>returned Promise is resolved with exit code</dt>
        <dd><pre><code>nodecat = sinon.stub();
const options = {
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
const result = nodecatCmd(RUNTIME_ARGS, options);
nodecat.yield(null);
return result.then((code) =&#x3E; {
  assert.strictEqual(code, 0);
});</code></pre></dd>
        <dt>returned Promise is rejected with Error</dt>
        <dd><pre><code>nodecat = sinon.stub();
const result = nodecatCmd(RUNTIME_ARGS, true);
return result.then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.instanceOf(err, TypeError); }
);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>nodecat</h1>
      <dl>
        <dt>concatenates a named file to outStream</dt>
        <dd><pre><code>const options = {
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
nodecat([filePath], options, (err) =&#x3E; {
  assert.ifError(err);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), fileContent);
    assert.strictEqual(options.errStream.read(), null);
    done();
  });
});</code></pre></dd>
        <dt>concatenates two named files to outStream</dt>
        <dd><pre><code>const options = {
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
nodecat([filePath, filePath], options, (err) =&#x3E; {
  assert.ifError(err);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(
      options.outStream.read(),
      Buffer.concat([fileContent, fileContent])
    );
    assert.strictEqual(options.errStream.read(), null);
    done();
  });
});</code></pre></dd>
        <dt>concatenates stdout to outStream</dt>
        <dd><pre><code>const testData = Buffer.from(&#x27;Stuff&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
nodecat([&#x27;-&#x27;], options, (err) =&#x3E; {
  assert.ifError(err);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), testData);
    assert.strictEqual(options.errStream.read(), null);
    done();
  });
});
inStream.end(testData);</code></pre></dd>
        <dt>concatenates stdout once when named twice</dt>
        <dd><pre><code>const testData = Buffer.from(&#x27;Stuff&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
nodecat([&#x27;-&#x27;, &#x27;-&#x27;], options, (err) =&#x3E; {
  assert.ifError(err);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), testData);
    assert.strictEqual(options.errStream.read(), null);
    done();
  });
});
inStream.end(testData);</code></pre></dd>
        <dt>continues with next file after read error</dt>
        <dd><pre><code>const errTest = new Error(&#x27;test read error&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
let callCount = 0;
nodecat([&#x27;-&#x27;, filePath], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.strictEqual(err, errTest);
  assert.strictEqual(err.fileName, &#x27;-&#x27;);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), fileContent);
    assert.match(
      options.errStream.read(),
      /^nodecat: -: .*test read error.*\n$/
    );
    done();
  });
});
inStream.emit(&#x27;error&#x27;, errTest);</code></pre></dd>
        <dt>does not retry stream after read error</dt>
        <dd><pre><code>const testData = Buffer.from(&#x27;Stuff&#x27;);
const errTest = new Error(&#x27;test read error&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
let callCount = 0;
nodecat([&#x27;-&#x27;, filePath, &#x27;-&#x27;], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.strictEqual(err, errTest);
  assert.strictEqual(err.fileName, &#x27;-&#x27;);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), fileContent);
    assert.match(
      options.errStream.read(),
      /^nodecat: -: .*test read error.*\n$/
    );
    done();
  });
});
inStream.emit(&#x27;error&#x27;, errTest);
inStream.end(testData);</code></pre></dd>
        <dt>returns AggregateError for multiple read errors</dt>
        <dd><pre><code>const errTest1 = new Error(&#x27;test read error 1&#x27;);
const errTest2 = new Error(&#x27;test read error 2&#x27;);
const errTest3 = new Error(&#x27;test read error 3&#x27;);
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const stream3 = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;file1.txt&#x27;: stream1,
    &#x27;file2.txt&#x27;: stream2,
    &#x27;file3.txt&#x27;: stream3
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
let callCount = 0;
nodecat([&#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;, &#x27;file3.txt&#x27;], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.instanceOf(err, AggregateError);
  assert.strictEqual(err.length, 3);
  assert.strictEqual(err[0], errTest1);
  assert.strictEqual(err[0].fileName, &#x27;file1.txt&#x27;);
  assert.strictEqual(err[1], errTest2);
  assert.strictEqual(err[1].fileName, &#x27;file2.txt&#x27;);
  assert.strictEqual(err[2], errTest3);
  assert.strictEqual(err[2].fileName, &#x27;file3.txt&#x27;);
  // Confirm that AggregateError.toString has contained messages
  const errMsgRE = new RegExp(
    &#x27;.*test read error 1.*\\n&#x27;
      + &#x27;.*test read error 2.*\\n&#x27;
      + &#x27;.*test read error 3.*\\n.*&#x27;
  );
  assert.match(String(err), errMsgRE);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), null);
    const errText = String(options.errStream.read());
    const errRE
      = new RegExp(&#x27;^nodecat: file1.txt: .*test read error 1.*\\n&#x27;
          + &#x27;nodecat: file2.txt: .*test read error 2.*\\n&#x27;
          + &#x27;nodecat: file3.txt: .*test read error 3.*\\n$&#x27;);
    assert.match(errText, errRE);
    done();
  });
});
stream1.emit(&#x27;error&#x27;, errTest1);
process.nextTick(() =&#x3E; {
  stream2.emit(&#x27;error&#x27;, errTest2);
  process.nextTick(() =&#x3E; {
    stream3.emit(&#x27;error&#x27;, errTest3);
  });
});</code></pre></dd>
        <dt>returns AggregateError for read and write errors</dt>
        <dd><pre><code>const errTestRead = new Error(&#x27;test read error&#x27;);
const errTestWrite = new Error(&#x27;test write error&#x27;);
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;file1.txt&#x27;: stream1,
    &#x27;file2.txt&#x27;: stream2
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
let callCount = 0;
nodecat([&#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.instanceOf(err, AggregateError);
  assert.strictEqual(err.length, 2);
  assert.strictEqual(err[0], errTestRead);
  assert.strictEqual(err[0].fileName, &#x27;file1.txt&#x27;);
  assert.strictEqual(err[1], errTestWrite);
  assert.strictEqual(err[1].fileName, undefined);
  options.outStream.end(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), null);
    const errText = String(options.errStream.read());
    const errRE
      = new RegExp(&#x27;^nodecat: file1.txt: .*test read error.*\\n&#x27;
          + &#x27;nodecat: .*test write error.*\\n$&#x27;);
    assert.match(errText, errRE);
    done();
  });
});
stream1.emit(&#x27;error&#x27;, errTestRead);
options.outStream.emit(&#x27;error&#x27;, errTestWrite);</code></pre></dd>
        <dt>stops writing after write error</dt>
        <dd><pre><code>const testData = Buffer.from(&#x27;Stuff&#x27;);
const errTest = new Error(&#x27;test write error&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
options.fileStreams[filePath] = {
  pipe: sinon.mock().never()
};
let callCount = 0;
nodecat([&#x27;-&#x27;, filePath], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.strictEqual(err, errTest);
  process.nextTick(() =&#x3E; {
    assert.strictEqual(options.outStream.read(), null);
    assert.match(
      options.errStream.read(),
      /^nodecat: .*test write error.*\n/
    );
    done();
  });
});
options.outStream.emit(&#x27;error&#x27;, errTest);
inStream.end(testData);</code></pre></dd>
        <dt>stops listening for read error after write error</dt>
        <dd><pre><code>const testData = Buffer.from(&#x27;Stuff&#x27;);
const errTestRead = new Error(&#x27;test read error&#x27;);
const errTestWrite = new Error(&#x27;test write error&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
options.fileStreams[filePath] = {
  pipe: sinon.mock().never()
};
// Assert would throw without this test listener.
inStream.on(&#x27;error&#x27;, function() {
  assert.strictEqual(listenerCount(this, &#x27;error&#x27;), 1);
});
let callCount = 0;
nodecat([&#x27;-&#x27;, filePath], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.strictEqual(err, errTestWrite);
  inStream.emit(&#x27;error&#x27;, errTestRead);
  setImmediate(() =&#x3E; {
    assert.strictEqual(options.outStream.read(), null);
    assert.match(
      options.errStream.read(),
      /^nodecat: .*test write error.*\n/
    );
    done();
  });
});
options.outStream.emit(&#x27;error&#x27;, errTestWrite);
inStream.emit(&#x27;error&#x27;, errTestRead);
inStream.end(testData);</code></pre></dd>
        <dt>stops listening for write error after callback</dt>
        <dd><pre><code>const testData = Buffer.from(&#x27;Stuff&#x27;);
const errTestWrite = new Error(&#x27;test write error&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
// Assert would throw without this test listener.
options.outStream.on(&#x27;error&#x27;, function() {
  assert.strictEqual(listenerCount(this, &#x27;error&#x27;), 1);
});
let callCount = 0;
nodecat([&#x27;-&#x27;], options, (err) =&#x3E; {
  callCount += 1;
  assert.strictEqual(callCount, 1);
  assert.ifError(err);
  options.outStream.emit(&#x27;error&#x27;, errTestWrite);
  setImmediate(() =&#x3E; {
    assert.deepEqual(options.outStream.read(), testData);
    assert.strictEqual(options.errStream.read(), null);
    done();
  });
});
inStream.end(testData);</code></pre></dd>
        <dt>throws TypeError for non-function callback</dt>
        <dd><pre><code>assert.throws(
  () =&#x3E; { nodecat([], {}, true); },
  TypeError,
  /\bcallback\b/
);</code></pre></dd>
        <dt>yields TypeError for non-Array-like fileNames</dt>
        <dd><pre><code>nodecat(&#x27;file.txt&#x27;, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\bfileNames\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-object options</dt>
        <dd><pre><code>nodecat([], true, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-object options.fileStreams</dt>
        <dd><pre><code>nodecat([], {fileStreams: true}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.fileStreams\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-Writable outStream</dt>
        <dd><pre><code>nodecat([], {outStream: new stream.Readable()}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.outStream\b/);
  done();
});</code></pre></dd>
        <dt>yields TypeError for non-Writable errStream</dt>
        <dd><pre><code>nodecat([], {errStream: new stream.Readable()}, (err) =&#x3E; {
  assert.instanceOf(err, TypeError);
  assert.match(err.message, /\boptions.errStream\b/);
  done();
});</code></pre></dd>
        <dt>returns undefined when called with a function</dt>
        <dd><pre><code>const result = nodecat([], done);
assert.strictEqual(result, undefined);</code></pre></dd>
        <dt>returns a Promise when called without a function</dt>
        <dd><pre><code>const result = nodecat([]);
assert(result instanceof global.Promise);</code></pre></dd>
        <dt>returned Promise is resolved after writing</dt>
        <dd><pre><code>let ended = false;
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
setImmediate(() =&#x3E; {
  ended = true;
  inStream.end();
});
return nodecat([&#x27;-&#x27;], options).then(() =&#x3E; {
  assert(ended);
});</code></pre></dd>
        <dt>returned Promise is rejected with argument Error</dt>
        <dd><pre><code>const result = nodecat([], true);
return result.then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.instanceOf(err, TypeError); }
);</code></pre></dd>
        <dt>returned Promise is rejected with read Error</dt>
        <dd><pre><code>const errTest = new Error(&#x27;test error&#x27;);
const inStream = new stream.PassThrough();
const options = {
  fileStreams: {
    &#x27;-&#x27;: inStream
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
setImmediate(() =&#x3E; {
  inStream.emit(&#x27;error&#x27;, errTest);
});
return nodecat([&#x27;-&#x27;], options).then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.strictEqual(err, errTest); }
);</code></pre></dd>
        <dt>returned Promise is rejected with write Error</dt>
        <dd><pre><code>const errTest = new Error(&#x27;test error&#x27;);
const options = {
  fileStreams: {
    &#x27;-&#x27;: new stream.PassThrough()
  },
  outStream: new stream.PassThrough(),
  errStream: new stream.PassThrough()
};
setImmediate(() =&#x3E; {
  options.outStream.emit(&#x27;error&#x27;, errTest);
});
return nodecat([&#x27;-&#x27;], options).then(
  sinon.mock().never(),
  (err) =&#x3E; { assert.strictEqual(err, errTest); }
);</code></pre></dd>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
